<!DOCTYPE html>  <html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>Rocket Launch Simulator</title>  
    <style>  
        * { margin: 0; padding: 0; box-sizing: border-box; }  
        body {  
            background: linear-gradient(to bottom, #1a1a2e 0%, #16213e 50%, #0f3460 100%);  
            overflow: hidden; font-family: 'Arial', sans-serif;  
        }  
        #ui {  
            position: absolute; top: 20px; left: 20px; color: #fff;  
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 15px;  
            backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);  
            max-width: 280px; z-index: 100; font-size: 13px;  
        }  
        #controls {  
            position: absolute; bottom: 20px; left: 20px; color: #fff;  
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 15px;  
            backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);  
            z-index: 100;  
        }  
        #launch-btn {  
            background: linear-gradient(45deg, #ff6b35, #ff8e3c);  
            border: none; color: #fff; padding: 12px 24px; border-radius: 25px;  
            font-size: 16px; font-weight: bold; cursor: pointer;  
            box-shadow: 0 4px 15px rgba(255,107,53,0.4);  
            transition: all 0.3s ease;  
        }  
        #launch-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255,107,53,0.6); }  
        #launch-btn:disabled { opacity: 0.6; cursor: not-allowed; }  
        @media (max-width: 768px) {  
            #ui, #controls { max-width: 200px; font-size: 11px; padding: 10px; }  
            #launch-btn { padding: 10px 20px; font-size: 14px; }  
        }  
    </style>  
</head>  
<body>  
    <div id="ui">  
        <h3>ðŸš€ Starship Launch Sim</h3>  
        <p><strong>Specs:</strong><br>  
        â€¢ Height: 50m â€¢ Diameter: 3.5m<br>  
        â€¢ Engines: 9x Raptor<br>  
        â€¢ Material: Stainless Steel 304L<br>  
        â€¢ Mission: Orbital Test Flight</p>  
    </div>  
    <div id="controls">  
        <p><strong>Controls:</strong><br>  
        Drag: Rotate â€¢ Scroll: Zoom â€¢ Right-drag: Pan</p>  
        <button id="launch-btn" onclick="startLaunch()">LAUNCH ðŸš€</button>  
    </div>  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>  
<script>  
    const scene = new THREE.Scene();  
    scene.fog = new THREE.Fog(0x1a1a2e, 100, 1200);  
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);  
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });  
    renderer.setSize(window.innerWidth, window.innerHeight);  
    renderer.shadowMap.enabled = true;  
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;  
    renderer.setClearColor(0x1a1a2e);  
    renderer.toneMapping = THREE.ACESFilmicToneMapping;  
    renderer.toneMappingExposure = 1.2;  
    document.body.appendChild(renderer.domElement);  

    // Enhanced lighting  
    const sunLight = new THREE.DirectionalLight(0xffffff, 2);  
    sunLight.position.set(100, 200, 100);  
    sunLight.castShadow = true;  
    sunLight.shadow.mapSize.width = sunLight.shadow.mapSize.height = 4096;  
    sunLight.shadow.camera.near = 0.5; sunLight.shadow.camera.far = 800;  
    sunLight.shadow.camera.left = sunLight.shadow.camera.bottom = -200;  
    sunLight.shadow.camera.right = sunLight.shadow.camera.top = 200;  
    scene.add(sunLight);  
    scene.add(new THREE.AmbientLight(0x404080, 0.4));  

    // Materials  
    const steelMat = new THREE.MeshPhysicalMaterial({  
        color: 0xe8e8e8, metalness: 0.95, roughness: 0.1, clearcoat: 1.0, clearcoatRoughness: 0.1  
    });  
    const engineMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });  
    const flameMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });  

    // Ground & Pad  
    const ground = new THREE.Mesh(  
        new THREE.PlaneGeometry(400, 400),  
        new THREE.MeshLambertMaterial({ color: 0x2a2a3a, transparent: true, opacity: 0.9 })  
    );  
    ground.rotation.x = -Math.PI/2; ground.receiveShadow = true;  
    scene.add(ground);  

    const pad = new THREE.Mesh(new THREE.CylinderGeometry(20, 20, 2, 32), new THREE.MeshLambertMaterial({ color: 0x666666 }));  
    pad.position.y = 1; pad.receiveShadow = true; scene.add(pad);  

    const trench = new THREE.Mesh(new THREE.BoxGeometry(40, 3, 12), flameMat);  
    trench.position.y = -0.5; scene.add(trench);  

    // Rocket Group  
    const rocket = new THREE.Group();  

    // First Stage (enhanced base)  
    const firstStage = new THREE.Mesh(new THREE.CylinderGeometry(1.75, 1.75, 32, 32), steelMat);  
    firstStage.position.y = 17; firstStage.castShadow = true;  
    rocket.add(firstStage);  

    // Aerodynamic fins at base  
    for(let i = 0; i < 4; i++) {  
        const fin = new THREE.Mesh(new THREE.BoxGeometry(0.1, 4, 1.5), steelMat);  
        const angle = i * Math.PI/2;  
        fin.position.set(Math.cos(angle) * 1.8, 3, Math.sin(angle) * 1.8);  
        fin.rotation.y = angle; rocket.add(fin);  
    }  

    // Second Stage  
    const secondStage = new THREE.Mesh(new THREE.CylinderGeometry(1.75, 1.75, 18, 32), steelMat);  
    secondStage.position.y = 42; secondStage.castShadow = true; rocket.add(secondStage);  

    // Enhanced Nose Cone (more realistic shape)  
    const noseGeometry = new THREE.ConeGeometry(1.75, 8, 32);  
    const noseCone = new THREE.Mesh(noseGeometry, steelMat);  
    noseCone.position.y = 55; noseCone.castShadow = true; rocket.add(noseCone);  

    // Hot Stage Ring  
    const ring = new THREE.Mesh(new THREE.CylinderGeometry(1.85, 1.85, 1.5, 32), new THREE.MeshLambertMaterial({ color: 0x444444 }));  
    ring.position.y = 33.5; rocket.add(ring);  

    // Engines (9 total - 1 center + 8 outer)  
    const engines = new THREE.Group();  
    const engineGeo = new THREE.CylinderGeometry(0.35, 0.45, 3, 12);  
      
    // Center engine  
    engines.add(new THREE.Mesh(engineGeo, engineMat));  
      
    // Outer ring of 8 engines  
    for(let i = 0; i < 8; i++) {  
        const angle = i * Math.PI/4; const radius = 1.3;  
        const engine = new THREE.Mesh(engineGeo, engineMat);  
        engine.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);  
        engines.add(engine);  
    }  
    engines.position.y = 2.5; rocket.add(engines);  

    // Landing Legs  
    for(let i = 0; i < 4; i++) {  
        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 12, 0.4), new THREE.MeshLambertMaterial({ color: 0x666666 }));  
        const angle = i * Math.PI/2;  
        leg.position.set(Math.cos(angle) * 1.9, 12, Math.sin(angle) * 1.9);  
        rocket.add(leg);  
    }  

    rocket.position.y = 0; scene.add(rocket);  

    // Launch Tower with Chopsticks  
    const tower = new THREE.Mesh(new THREE.BoxGeometry(3, 80, 3), new THREE.MeshLambertMaterial({ color: 0x555555 }));  
    tower.position.set(25, 40, 0); tower.castShadow = true; scene.add(tower);  

    // Chopsticks  
    const chopstick1 = new THREE.Mesh(new THREE.BoxGeometry(0.8, 20, 0.8), new THREE.MeshLambertMaterial({ color: 0x666666 }));  
    chopstick1.position.set(20, 25, 3); scene.add(chopstick1);  
    const chopstick2 = new THREE.Mesh(new THREE.BoxGeometry(0.8, 20, 0.8), new THREE.MeshLambertMaterial({ color: 0x666666 }));  
    chopstick2.position.set(20, 25, -3); scene.add(chopstick2);  

    // Service Arms  
    const arm1 = new THREE.Mesh(new THREE.BoxGeometry(20, 0.8, 1.5), new THREE.MeshLambertMaterial({ color: 0x777777 }));  
    arm1.position.set(15, 35, 0); scene.add(arm1);  
    const arm2 = new THREE.Mesh(new THREE.BoxGeometry(18, 0.8, 1.2), new THREE.MeshLambertMaterial({ color: 0x777777 }));  
    arm2.position.set(14, 45, 0); scene.add(arm2);  

    // Particle Systems  
    function createParticles(count, color, size) {  
        const geometry = new THREE.BufferGeometry();  
        const positions = new Float32Array(count * 3);  
        const velocities = [];  
          
        for(let i = 0; i < count; i++) {  
            positions[i*3] = (Math.random()-0.5) * 8;  
            positions[i*3+1] = Math.random() * 5;  
            positions[i*3+2] = (Math.random()-0.5) * 8;  
            velocities.push(new THREE.Vector3((Math.random()-0.5)*0.02, Math.random()*0.05+0.02, (Math.random()-0.5)*0.02));  
        }  
          
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));  
        const material = new THREE.PointsMaterial({ color, size, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending });  
        const particles = new THREE.Points(geometry, material);  
        particles.userData = { velocities, maxY: 100 };  
        return particles;  
    }  

    const vapor = createParticles(200, 0xffffff, 0.8);  
    vapor.position.set(0, 4, 0); scene.add(vapor);  

    let flames = null, exhaust = null;  

    // Launch Animation Variables  
    let isLaunching = false, launchTime = 0, separationTime = 8000, landingTime = 30000;  
    let firstStageGroup = null, launchStarted = false;  

    function startLaunch() {  
        if(isLaunching) return;  
        isLaunching = true; launchTime = Date.now();  
        document.getElementById('launch-btn').disabled = true;  
        document.getElementById('launch-btn').innerHTML = 'LAUNCHING... ðŸ”¥';  
          
        // Create flame effects  
        flames = createParticles(500, 0xff6600, 1.5);  
        flames.position.set(0, 0, 0); scene.add(flames);  
          
        exhaust = createParticles(300, 0xffaa44, 1.2);  
        exhaust.position.set(0, -5, 0); scene.add(exhaust);  
          
        setTimeout(() => launchStarted = true, 100);  
    }  

    function separateStages() {  
        // Create first stage group for landing sequence  
        firstStageGroup = new THREE.Group();  
        const fs = firstStage.clone(); fs.position.copy(firstStage.position);  
        const eng = engines.clone(); eng.position.copy(engines.position);  
          
        // Add landing legs to first stage  
        for(let i = 0; i < 4; i++) {  
            const leg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 12, 0.4), new THREE.MeshLambertMaterial({ color: 0x666666 }));  
            const angle = i * Math.PI/2;  
            leg.position.set(Math.cos(angle) * 1.9, 12, Math.sin(angle) * 1.9);  
            firstStageGroup.add(leg);  
        }  
          
        firstStageGroup.add(fs, eng);  
        firstStageGroup.position.copy(rocket.position);  
        scene.add(firstStageGroup);  
          
        // Remove flame effects  
        if(flames) { scene.remove(flames); flames = null; }  
        if(exhaust) { scene.remove(exhaust); exhaust = null; }  
          
        document.getElementById('launch-btn').innerHTML = 'STAGE SEPARATED ðŸš€';  
    }  

    // Controls (Mobile-friendly)  
    let mouse = { x: 0, y: 0, down: false, button: 0 };  
    let touch = { x: 0, y: 0, active: false, zoom: 0 };  

    function handleStart(e, isTouch = false) {  
        if(isTouch) {  
            touch.active = true; touch.x = e.touches[0].clientX; touch.y = e.touches[0].clientY;  
        } else {  
            mouse.down = true; mouse.button = e.button; mouse.x = e.clientX; mouse.y = e.clientY;  
        }  
    }  

    function handleMove(e, isTouch = false) {  
        const x = isTouch ? e.touches[0].clientX : e.clientX;  
        const y = isTouch ? e.touches[0].clientY : e.clientY;  
          
        if((isTouch && touch.active) || (!isTouch && mouse.down)) {  
            const deltaX = x - (isTouch ? touch.x : mouse.x);  
            const deltaY = y - (isTouch ? touch.y : mouse.y);  
              
            if(!isTouch && mouse.button === 2) return; // Skip right-click pan for simplicity  
              
            // Rotate camera  
            const radius = Math.sqrt(camera.position.x*camera.position.x + camera.position.z*camera.position.z);  
            const angle = Math.atan2(camera.position.z, camera.position.x) - deltaX * 0.005;  
            camera.position.x = Math.cos(angle) * radius;  
            camera.position.z = Math.sin(angle) * radius;  
            camera.position.y = Math.max(5, camera.position.y - deltaY * 0.3);  
        }  
          
        if(isTouch) { touch.x = x; touch.y = y; } else { mouse.x = x; mouse.y = y; }  
    }  

    function handleEnd(isTouch = false) {  
        if(isTouch) touch.active = false; else mouse.down = false;  
    }  

    // Event listeners  
    renderer.domElement.addEventListener('mousedown', e => handleStart(e));  
    renderer.domElement.addEventListener('mousemove', e => handleMove(e));  
    renderer.domElement.addEventListener('mouseup', () => handleEnd());  
    renderer.domElement.addEventListener('touchstart', e => { e.preventDefault(); handleStart(e, true); });  
    renderer.domElement.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e, true); });  
    renderer.domElement.addEventListener('touchend', e => { e.preventDefault(); handleEnd(true); });  
    renderer.domElement.addEventListener('wheel', e => {  
        const factor = e.deltaY > 0 ? 1.05 : 0.95;  
        camera.position.multiplyScalar(factor);  
        camera.position.y = Math.max(5, camera.position.y);  
    });  
    renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());  

    // Animation Loop  
    function animate() {  
        requestAnimationFrame(animate);  
          const elapsed = Date.now() - launchTime;  
        if(isLaunching) {  
            
            const t = elapsed / 1000;  
              
            if(elapsed < separationTime && launchStarted) {  
                // Launch phase - rocket goes up with acceleration  
                const height = Math.pow(t, 2) * 20;  
                rocket.position.y = height;  
                  
                // Animate flames following rocket  
                if(flames) {  
                    const pos = flames.geometry.attributes.position;  
                    const vel = flames.userData.velocities;  
                    for(let i = 0; i < pos.count; i++) {  
                        pos.array[i*3] += vel[i].x * 2;  
                        pos.array[i*3+1] += vel[i].y * 5;  
                        pos.array[i*3+2] += vel[i].z * 2;  
                        if(pos.array[i*3+1] > 40) {  
                            pos.array[i*3] = (Math.random()-0.5) * 6;  
                            pos.array[i*3+1] = -8;  
                            pos.array[i*3+2] = (Math.random()-0.5) * 6;  
                        }  
                    }  
                    pos.needsUpdate = true;  
                    flames.position.copy(rocket.position);  
                    flames.position.y -= 8;  
                }  
                  
                // Dynamic camera following rocket  
                const targetY = Math.max(50, height + 30);  
                camera.position.y = THREE.MathUtils.lerp(camera.position.y, targetY, 0.02);  
                  
            } else if(elapsed >= separationTime && !firstStageGroup) {  
                // Trigger stage separation  
                separateStages();  
                  
                // Remove first stage from main rocket  
                rocket.remove(firstStage, engines);  
                secondStage.position.y = 10;  
                noseCone.position.y = 23;  
                ring.position.y = 1;  
                  
            } else if(firstStageGroup) {  
                // First stage autonomous return sequence  
                const returnT = (elapsed - separationTime) / (landingTime - separationTime);  
                const rocketHeight = rocket.position.y;  
                  
                if(returnT < 0.3) {  
                    // Stage continues up briefly then starts descent  
                    firstStageGroup.position.y = rocketHeight - returnT * 30;  
                    firstStageGroup.rotation.z = Math.sin(returnT * 8) * 0.15; // Slight tumble  
                      
                } else if(returnT < 0.8) {  
                    // Controlled descent with landing burn  
                    const descentT = (returnT - 0.3) / 0.5;  
                    const startHeight = rocketHeight - 9;  
                    const landHeight = 25; // Chopstick height  
                      
                    // Smooth descent curve  
                    const currentHeight = startHeight - (startHeight - landHeight) * Math.pow(descentT, 0.6);  
                    firstStageGroup.position.y = Math.max(landHeight, currentHeight);  
                      
                    // Stabilize rotation  
                    firstStageGroup.rotation.z *= (1 - descentT);  
                      
                    // Move towards chopsticks  
                    const targetX = 20 * Math.min(1, descentT * 2);  
                    firstStageGroup.position.x = THREE.MathUtils.lerp(firstStageGroup.position.x, targetX, 0.05);  
                      
                    // Landing burn particles  
                    if(descentT > 0.5 && !firstStageGroup.userData.landingBurn) {  
                        const landingFlame = createParticles(150, 0x00aaff, 1.2);  
                        landingFlame.position.copy(firstStageGroup.position);  
                        landingFlame.position.y -= 16;  
                        scene.add(landingFlame);  
                        firstStageGroup.userData.landingBurn = landingFlame;  
                    }  
                      
                } else if(returnT >= 0.8) {  
                    // Caught by chopsticks - final positioning  
                    firstStageGroup.position.set(20, 25, 0);  
                    firstStageGroup.rotation.z = 0;  
                      
                    // Remove landing burn effect  
                    if(firstStageGroup.userData.landingBurn) {  
                        scene.remove(firstStageGroup.userData.landingBurn);  
                        firstStageGroup.userData.landingBurn = null;  
                    }  
                      
                    if(returnT > 0.9) {  
                        document.getElementById('launch-btn').innerHTML = 'LANDING SUCCESS! âœ…';  
                    }  
                }  
                  
                // Second stage continues to orbit  
                if(returnT > 0.2) {  
                    rocket.position.y += 0.8; // Slower continued ascent  
                }  
            }  
        }  
          
        // Animate base vapor effects  
        const pos = vapor.geometry.attributes.position;  
        const vel = vapor.userData.velocities;  
        for(let i = 0; i < pos.count; i++) {  
            pos.array[i*3] += vel[i].x; pos.array[i*3+1] += vel[i].y; pos.array[i*3+2] += vel[i].z;  
            if(pos.array[i*3+1] > 60) {   
                pos.array[i*3+1] = 4;   
                pos.array[i*3] = (Math.random()-0.5)*8;   
                pos.array[i*3+2] = (Math.random()-0.5)*8;   
            }  
        }  
        pos.needsUpdate = true;  
          
        // Smart camera tracking  
        let lookAtTarget;  
        if(isLaunching && firstStageGroup && elapsed > separationTime) {  
            // During landing, focus on first stage  
            lookAtTarget = firstStageGroup.position;  
        } else {  
            // Focus on main rocket  
            lookAtTarget = new THREE.Vector3(0, Math.max(25, rocket.position.y), 0);  
        }  
          
        camera.lookAt(lookAtTarget);  
        renderer.render(scene, camera);  
    }  
      
    // Initial setup  
    camera.position.set(120, 50, 120);  
    window.addEventListener('resize', () => {  
        camera.aspect = window.innerWidth / window.innerHeight;  
        camera.updateProjectionMatrix();  
        renderer.setSize(window.innerWidth, window.innerHeight);  
    });  
      
    animate();  
</script>

</body>  
</html>
